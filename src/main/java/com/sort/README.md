# Sort (internal sort)

* Language : Java
* IDE : IntelliJ IDEA
* 날짜 : 20.05.01

# Description

<img src="/doc/sort/time_complexity.png">

## 버블 정렬

서로 인접한 두 원소를 비교하며 정렬하는 알고리즘으로,  마지막부터 정렬되면서 차례 차례 내려온다.

<br>

#### 장.단점

단점 
- 시간 복잡도 가장 최악
- 최종 정렬 위치에 있는 경우라도 교환되는 일이 일어남.

장점 
- 구현은 가장 간단

<br>
<br>

## 선택 정렬

버블 정렬과 반대로, 가장 작은 값을 앞에서부터 채우면서 정렬하는 형식

<br>

#### 장.단점

단점 
- 같은 값끼리도 교환 연산이 발생함

장점 
- 자료 이동 횟수가 미리 결정된다.
- 안정적인 정렬

<br>
<br>

## 삽입 정렬

삽입 정렬은 매 순간 key값이 삽입할 위치를 지정하면서 정렬하는 알고리즘이다.

<img src="/doc/sort/insertionsort.png">

#### 장.단점

단점 
- 비교적 레코드들의 이동이 많음
- 따라서, 레코드 수가 많을수록 적합하지 않다.

장점 
- 안정적인 정렬
- 이미 레코드가 정렬돼 있다면 매우 효율적인 알고리즘 ( O(n) )

<br>
<br>

## 퀵 정렬

quick sort는 분할 정복 알고리즘 중 하나이다. 

( 분할 정복 = 문제를 분리해서 각각 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략 )

dividie - 최소 단위까지 나눈다. (2개일 때까지)
conquer - 각각 해결한다.
combie - 해결한 배열을 다시 결합함.

<img src="/doc/sort/quicksort.png">

<br>

#### 장.단점

단점 
- 불안정한 정렬.(데이터 분포에 따라 수행시간의 영향을 끼침) => 피벗의 위치가 관건.
- 최악의 경우 O(N^2)이 걸린다. (리스트가 계속 완전 불균형하게 나누어질 때)

장점 
- time - complexity O(nlogn)을 가진 정렬 알고리즘 중 가장 빠름.

<br>
<br>

## merge sort

merge sort는 분할 정복 알고리즘 중 하나이다. 

( 분할 정복 = 문제를 분리해서 각각 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략 )

dividie - 최소 단위까지 나눈다. (2개일 때까지) <br>
conquer - 각각 해결한다. <br>
combie - 해결한 배열을 다시 결합함.

<img src="/doc/sort/mergesort.png">

이 중 conquer에 대해서 설명한다.

두 정렬된 배열로 예를 들어본다.

```
a = {2,3,5,9}  b = {1,4,6,8}
result = {}
```

```
a = {2,3,5,9}  b = {4,6,8}
2 < 1 이므로, 1입력 (입력된 것은 제외)
result = {1}
```

```
a = {3,5,9}  b = {4,6,8}
2 < 4 이므로, 2입력
result = {1, 2}
```

```
a = {5,9}  b = {4,6,8}
3 < 4 이므로, 3입력
result = {1, 2, 3}
```

```
a = {5,9}  b = {6,8}
5 > 4 이므로, 4입력
result = {1, 2, 3, 4}
```

```
a = {9}  b = {6,8}
5 < 6 이므로, 5입력
result = {1, 2, 3, 4, 5}
```

```
a = {9}  b = {8}
9 > 6 이므로, 6입력
result = {1, 2, 3, 4, 5, 6}
```

```
a = {9}  b = {}
9 > 8 이므로, 8입력
result = {1, 2, 3, 4, 5, 6, 8}
```

```
a = {}  b = {}
나머지 차례로 입력
result = {1, 2, 3, 4, 5, 6, 8, 9}
```

이렇게 두 정렬된 배열을 하나의 정렬된 배열로 병합하는 방법이다. 이를 착안하여 작은 조각에서 부터 출발하면, 결국 정렬된 하나의 배열을 얻을 수 있다.

<br>


#### 장.단점

단점 
- 임시 배열이 필요하다.

장점 
- 안정적이다. ( 데이터의 분포 영향을 덜 받음)
- 연결 리스트로 작성 시 데이터의 이동이 더 작아짐.

<br>
<br>